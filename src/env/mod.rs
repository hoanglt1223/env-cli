//! Environment variable handling.
//!
//! This module provides utilities for working with environment variables.

use crate::error::{EnvCliError, Result};
use std::collections::HashMap;

/// Environment variable manager.
pub struct EnvManager {
    variables: HashMap<String, String>,
}

impl EnvManager {
    /// Create a new environment manager.
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
        }
    }

    /// Load environment variables from current process.
    pub fn load_current(&mut self) -> Result<()> {
        for (key, value) in std::env::vars() {
            self.variables.insert(key, value);
        }
        Ok(())
    }

    /// Load environment variables from .env file.
    pub fn load_from_file(&mut self, path: &std::path::Path) -> Result<()> {
        if !path.exists() {
            return Err(EnvCliError::FileSystem(format!(
                "Environment file not found: {}",
                path.display()
            )));
        }

        let content = std::fs::read_to_string(path)?;

        for line in content.lines() {
            let line = line.trim();

            // Skip empty lines and comments
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            // Parse KEY=VALUE format, handling quotes and exports
            if let Some((key, value)) = parse_env_line(line)? {
                self.variables.insert(key, value);
            }
        }

        Ok(())
    }

    /// Get an environment variable.
    pub fn get(&self, key: &str) -> Option<&String> {
        self.variables.get(key)
    }

    /// Set an environment variable.
    pub fn set(&mut self, key: String, value: String) {
        self.variables.insert(key, value);
    }

    /// Remove an environment variable.
    pub fn remove(&mut self, key: &str) -> Option<String> {
        self.variables.remove(key)
    }

    /// List all environment variables.
    pub fn list(&self) -> impl Iterator<Item = (&String, &String)> {
        self.variables.iter()
    }

    /// Save environment variables to file.
    pub fn save_to_file(&self, path: &std::path::Path) -> Result<()> {
        // Create parent directory if it doesn't exist
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }

        let mut content = String::new();

        // Add header comment
        content.push_str("# Environment variables\n");
        content.push_str("# Generated by env-cli\n\n");

        // Sort variables for consistent output
        let mut sorted_vars: Vec<_> = self.variables.iter().collect();
        sorted_vars.sort_by_key(|(k, _)| *k);

        for (key, value) in sorted_vars {
            // Quote values that contain spaces, special characters, or are empty
            let formatted_value = if value.is_empty()
                || value.contains(' ')
                || value.contains('\n')
                || value.contains('\t')
                || value.contains('"')
                || value.contains('\'')
            {
                format!("\"{}\"", value.replace('"', "\\\""))
            } else {
                value.clone()
            };

            content.push_str(&format!("{}={}\n", key, formatted_value));
        }

        std::fs::write(path, content)?;
        Ok(())
    }

    /// Validate environment variables.
    pub fn validate(&self, required: &[String]) -> Vec<String> {
        let mut missing = Vec::new();
        for key in required {
            if !self.variables.contains_key(key) {
                missing.push(key.clone());
            }
        }
        missing
    }

    /// Filter variables by pattern.
    pub fn filter_by_pattern(&self, pattern: &str) -> HashMap<String, String> {
        let regex = regex::Regex::new(pattern)
            .unwrap_or_else(|_| regex::Regex::new(&regex::escape(pattern)).unwrap());

        self.variables
            .iter()
            .filter(|(key, _)| regex.is_match(key))
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect()
    }
}

impl Default for EnvManager {
    fn default() -> Self {
        Self::new()
    }
}

/// Environment variable usage information.
#[derive(Debug, Clone)]
pub struct EnvUsage {
    /// Variable name
    pub name: String,
    /// Files where it's used
    pub files: Vec<String>,
    /// Line numbers in each file
    pub lines: Vec<usize>,
    /// Whether it's required
    pub required: bool,
    /// Description (if available)
    pub description: Option<String>,
}

impl EnvUsage {
    /// Create new environment usage information.
    pub fn new(name: String) -> Self {
        Self {
            name,
            files: Vec::new(),
            lines: Vec::new(),
            required: false,
            description: None,
        }
    }

    /// Add a usage location.
    pub fn add_usage(&mut self, file: String, line: usize) {
        self.files.push(file);
        self.lines.push(line);
    }

    /// Mark as required.
    pub fn set_required(&mut self, required: bool) {
        self.required = required;
    }

    /// Set description.
    pub fn set_description(&mut self, description: String) {
        self.description = Some(description);
    }
}

/// Parse a single line from a .env file.
/// Handles various formats including: KEY=VALUE, KEY="VALUE", export KEY=VALUE, etc.
fn parse_env_line(line: &str) -> Result<Option<(String, String)>> {
    let line = line.trim();

    // Remove 'export ' prefix if present
    let line = if line.starts_with("export ") {
        &line[7..] // Remove "export " (7 characters)
    } else {
        line
    };

    // Find the first '=' character
    if let Some(eq_pos) = line.find('=') {
        let key = line[..eq_pos].trim().to_string();
        let mut value = line[eq_pos + 1..].trim().to_string();

        // Validate key format (should be alphanumeric, underscore, and not start with digit)
        if !is_valid_env_key(&key) {
            return Err(EnvCliError::InvalidFormat(format!(
                "Invalid environment variable key: '{}'",
                key
            )));
        }

        // Handle quoted values
        if (value.starts_with('"') && value.ends_with('"'))
            || (value.starts_with('\'') && value.ends_with('\''))
        {
            // Remove quotes and unescape
            value = value[1..value.len() - 1].to_string();
            value = unescape_string(&value);
        } else {
            // Handle unquoted values - remove any trailing comments
            if let Some(comment_pos) = value.find('#') {
                value = value[..comment_pos].trim().to_string();
            }
        }

        Ok(Some((key, value)))
    } else {
        // Line doesn't contain '=', skip it
        Ok(None)
    }
}

/// Check if a string is a valid environment variable key.
fn is_valid_env_key(key: &str) -> bool {
    if key.is_empty() {
        return false;
    }

    // First character must be a letter or underscore
    if !key.chars().next().unwrap().is_alphabetic() && key.chars().next().unwrap() != '_' {
        return false;
    }

    // All characters must be alphanumeric or underscore
    key.chars().all(|c| c.is_alphanumeric() || c == '_')
}

/// Unescape escape sequences in a string.
fn unescape_string(s: &str) -> String {
    s.replace("\\\"", "\"")
        .replace("\\'", "'")
        .replace("\\n", "\n")
        .replace("\\t", "\t")
        .replace("\\r", "\r")
        .replace("\\\\", "\\")
}
