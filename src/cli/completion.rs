//! Shell completion generation and management.
//!
//! This module provides comprehensive shell completion support for env-cli,
//! including bash, zsh, fish, and PowerShell completion scripts.

use crate::error::Result;
use std::fmt::Write;

/// Shell completion generator.
pub struct CompletionGenerator {}

impl CompletionGenerator {
    /// Create a new completion generator.
    pub fn new() -> Self {
        Self {}
    }

    /// Generate completion script for the specified shell.
    pub fn generate(&self, shell: Shell) -> Result<String> {
        match shell {
            Shell::Bash => self.generate_bash(),
            Shell::Zsh => self.generate_zsh(),
            Shell::Fish => self.generate_fish(),
            Shell::PowerShell => self.generate_powershell(),
        }
    }

    /// Generate bash completion script.
    fn generate_bash(&self) -> Result<String> {
        let mut script = String::new();

        // Header
        writeln!(script, "# bash completion for env-cli")?;
        writeln!(script, "# Generated by env-cli completion generation")?;
        writeln!(script)?;

        // Completion function
        writeln!(script, "_env_cli_completion() {{")?;
        writeln!(script, "    local cur prev words cword")?;
        writeln!(script, "    _init_completion || return")?;
        writeln!(script)?;

        // Command completion
        writeln!(script, "    case ${{prev}} in")?;
        writeln!(script, "        env)")?;
        writeln!(script, "            COMPREPLY=($(compgen -W 'init switch scan validate sync generate status' -- \"$cur\"))")?;
        writeln!(script, "            return")?;
        writeln!(script, "            ;;")?;
        writeln!(script)?;

        // Switch command options
        writeln!(script, "        switch)")?;
        writeln!(script, "            local environments")?;
        writeln!(script, "            environments=$({{command:-env}} status 2>/dev/null | grep -E \"^\\*?\\s+\\w+\" | cut -d' ' -f2 | grep -v \"^$\")")?;
        writeln!(
            script,
            "            COMPREPLY=($(compgen -W \"$environments\" -- \"$cur\"))"
        )?;
        writeln!(script, "            return")?;
        writeln!(script, "            ;;")?;
        writeln!(script)?;

        // Validate command options
        writeln!(script, "        validate)")?;
        writeln!(script, "            COMPREPLY=($(compgen -W \"current $({{command:-env}} status 2>/dev/null | grep -E \"^\\*?\\s+\\w+\" | cut -d' ' -f2 | grep -v \"^$\")\" -- \"$cur\"))")?;
        writeln!(script, "            return")?;
        writeln!(script, "            ;;")?;
        writeln!(script)?;

        // Sync command options
        writeln!(script, "        sync)")?;
        writeln!(script, "            local environments")?;
        writeln!(script, "            environments=$({{command:-env}} status 2>/dev/null | grep -E \"^\\*?\\s+\\w+\" | cut -d' ' -f2 | grep -v \"^$\")")?;
        writeln!(
            script,
            "            COMPREPLY=($(compgen -W \"$environments\" -- \"$cur\"))"
        )?;
        writeln!(script, "            return")?;
        writeln!(script, "            ;;")?;
        writeln!(script)?;

        // Scan command options
        writeln!(script, "        scan)")?;
        writeln!(
            script,
            "            COMPREPLY=($(compgen -A directory -- \"$cur\"))"
        )?;
        writeln!(script, "            return")?;
        writeln!(script, "            ;;")?;
        writeln!(script)?;

        // Generate command options
        writeln!(script, "        generate)")?;
        writeln!(
            script,
            "            COMPREPLY=($(compgen -A file -- \"$cur\"))"
        )?;
        writeln!(script, "            return")?;
        writeln!(script, "            ;;")?;
        writeln!(script)?;

        // Common options
        writeln!(script, "        -*)")?;
        writeln!(script, "            case ${{words[1]}} in")?;
        writeln!(script, "                switch)")?;
        writeln!(
            script,
            "                    COMPREPLY=($(compgen -W '--yes' -- \"$cur\"))"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script, "                scan)")?;
        writeln!(
            script,
            "                    COMPREPLY=($(compgen -W '--format --hidden' -- \"$cur\"))"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script, "                validate)")?;
        writeln!(
            script,
            "                    COMPREPLY=($(compgen -W '--env --check-unused' -- \"$cur\"))"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script, "                sync)")?;
        writeln!(
            script,
            "                    COMPREPLY=($(compgen -W '--yes' -- \"$cur\"))"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script, "                generate)")?;
        writeln!(script, "                    COMPREPLY=($(compgen -W '--output --comments --docs --scan-dir' -- \"$cur\"))")?;
        writeln!(script, "                    ;;")?;
        writeln!(script, "                status)")?;
        writeln!(
            script,
            "                    COMPREPLY=($(compgen -W '--verbose' -- \"$cur\"))"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script, "                *)")?;
        writeln!(
            script,
            "                    COMPREPLY=($(compgen -W '--help' -- \"$cur\"))"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script, "            esac")?;
        writeln!(script, "            return")?;
        writeln!(script, "            ;;")?;
        writeln!(script)?;

        writeln!(script, "    esac")?;
        writeln!(script)?;

        // Default completion
        writeln!(script, "    COMPREPLY=($(compgen -W '--help' -- \"$cur\"))")?;
        writeln!(script, "}}")?;
        writeln!(script)?;

        // Register completion
        writeln!(script, "complete -F _env_cli_completion env")?;

        Ok(script)
    }

    /// Generate zsh completion script.
    fn generate_zsh(&self) -> Result<String> {
        let mut script = String::new();

        // Header
        writeln!(script, "#compdef env")?;
        writeln!(script, "# zsh completion for env-cli")?;
        writeln!(script)?;

        // Completion function
        writeln!(script, "_env_cli() {{")?;
        writeln!(script, "    local -a commands")?;
        writeln!(script)?;

        // Define commands
        writeln!(script, "    commands=(")?;
        writeln!(
            script,
            "        'init:Initialize project with env structure'"
        )?;
        writeln!(script, "        'switch:Switch between environments'")?;
        writeln!(script, "        'scan:Scan code for env usage'")?;
        writeln!(
            script,
            "        'validate:Validate environment configuration'"
        )?;
        writeln!(script, "        'sync:Sync environments safely'")?;
        writeln!(script, "        'generate:Generate .env.example file'")?;
        writeln!(script, "        'status:Show current environment status'")?;
        writeln!(script, "    )")?;
        writeln!(script)?;

        // Define command-line options
        writeln!(script, "    _arguments -C \\")?;
        writeln!(script, "        '1: :->command' \\")?;
        writeln!(script, "        '*:: :->args' && ret=0")?;
        writeln!(script)?;

        writeln!(script, "    case $state in")?;
        writeln!(script, "        command)")?;
        writeln!(script, "            _describe 'commands' commands")?;
        writeln!(script, "            ;;")?;
        writeln!(script)?;

        writeln!(script, "        args)")?;
        writeln!(script, "            case $line[1] in")?;
        writeln!(script)?;

        // Init command
        writeln!(script, "                init)")?;
        writeln!(script, "                    _arguments \\")?;
        writeln!(script, "                        '--force[Force initialization even if already initialized]' \\")?;
        writeln!(
            script,
            "                        '--help[Show help message]'"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script)?;

        // Switch command
        writeln!(script, "                switch)")?;
        writeln!(script, "                    local environments")?;
        writeln!(script, "                    environments=($({{command:-env}} status 2>/dev/null | grep -E \"^\\*?\\s+\\w+\" | cut -d' ' -f2 | grep -v \"^$\"))")?;
        writeln!(script, "                    _arguments \\")?;
        writeln!(script, "                        '1: :($environments)' \\")?;
        writeln!(
            script,
            "                        '--yes[Skip confirmation before switching]' \\"
        )?;
        writeln!(
            script,
            "                        '--help[Show help message]'"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script)?;

        // Scan command
        writeln!(script, "                scan)")?;
        writeln!(script, "                    _arguments \\")?;
        writeln!(script, "                        '1: :_directories' \\")?;
        writeln!(
            script,
            "                        '--format[Output format]:format:(text json yaml)' \\"
        )?;
        writeln!(
            script,
            "                        '--hidden[Include hidden files and directories]' \\"
        )?;
        writeln!(
            script,
            "                        '--help[Show help message]'"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script)?;

        // Validate command
        writeln!(script, "                validate)")?;
        writeln!(script, "                    local environments")?;
        writeln!(script, "                    environments=($({{command:-env}} status 2>/dev/null | grep -E \"^\\*?\\s+\\w+\" | cut -d' ' -f2 | grep -v \"^$\"))")?;
        writeln!(script, "                    _arguments \\")?;
        writeln!(script, "                        '--env[Environment to validate]:environment:(current $environments)' \\")?;
        writeln!(
            script,
            "                        '--check-unused[Check for unused environment variables]' \\"
        )?;
        writeln!(
            script,
            "                        '--help[Show help message]'"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script)?;

        // Sync command
        writeln!(script, "                sync)")?;
        writeln!(script, "                    local environments")?;
        writeln!(script, "                    environments=($({{command:-env}} status 2>/dev/null | grep -E \"^\\*?\\s+\\w+\" | cut -d' ' -f2 | grep -v \"^$\"))")?;
        writeln!(script, "                    _arguments \\")?;
        writeln!(
            script,
            "                        '1:source: :($environments)' \\"
        )?;
        writeln!(
            script,
            "                        '2:target: :($environments)' \\"
        )?;
        writeln!(
            script,
            "                        '--yes[Skip confirmation before syncing]' \\"
        )?;
        writeln!(
            script,
            "                        '--help[Show help message]'"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script)?;

        // Generate command
        writeln!(script, "                generate)")?;
        writeln!(script, "                    _arguments \\")?;
        writeln!(
            script,
            "                        '--output[Output file path]:file:_files' \\"
        )?;
        writeln!(
            script,
            "                        '--comments[Include comments describing each variable]' \\"
        )?;
        writeln!(
            script,
            "                        '--docs[Generate comprehensive documentation]' \\"
        )?;
        writeln!(script, "                        '--scan-dir[Directory to scan for environment variables]:directory:_directories' \\")?;
        writeln!(
            script,
            "                        '--help[Show help message]'"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script)?;

        // Status command
        writeln!(script, "                status)")?;
        writeln!(script, "                    _arguments \\")?;
        writeln!(
            script,
            "                        '--verbose[Show detailed information]' \\"
        )?;
        writeln!(
            script,
            "                        '--help[Show help message]'"
        )?;
        writeln!(script, "                    ;;")?;
        writeln!(script)?;

        writeln!(script, "            esac")?;
        writeln!(script, "            ;;")?;
        writeln!(script)?;

        writeln!(script, "    esac")?;
        writeln!(script, "}}")?;
        writeln!(script)?;

        // Register completion
        writeln!(script, "_env_cli \"$@\"")?;

        Ok(script)
    }

    /// Generate fish completion script.
    fn generate_fish(&self) -> Result<String> {
        let mut script = String::new();

        // Header
        writeln!(script, "# fish completion for env-cli")?;
        writeln!(script, "# Generated by env-cli completion generation")?;
        writeln!(script)?;

        // Main completion command
        writeln!(script, "complete -c env -f")?;
        writeln!(script)?;

        // Command completions
        writeln!(script, "# Main commands")?;
        writeln!(script, "complete -c env -n \"__fish_use_subcommand\" -a init -d 'Initialize project with env structure'")?;
        writeln!(script, "complete -c env -n \"__fish_use_subcommand\" -a switch -d 'Switch between environments'")?;
        writeln!(
            script,
            "complete -c env -n \"__fish_use_subcommand\" -a scan -d 'Scan code for env usage'"
        )?;
        writeln!(script, "complete -c env -n \"__fish_use_subcommand\" -a validate -d 'Validate environment configuration'")?;
        writeln!(
            script,
            "complete -c env -n \"__fish_use_subcommand\" -a sync -d 'Sync environments safely'"
        )?;
        writeln!(script, "complete -c env -n \"__fish_use_subcommand\" -a generate -d 'Generate .env.example file'")?;
        writeln!(script, "complete -c env -n \"__fish_use_subcommand\" -a status -d 'Show current environment status'")?;
        writeln!(script)?;

        // Init command options
        writeln!(script, "# init command options")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from init\" -l force -d 'Force initialization even if already initialized'")?;
        writeln!(script)?;

        // Switch command options
        writeln!(script, "# switch command options")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from switch\" -l yes -d 'Skip confirmation before switching'")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from switch; and not __fish_seen_argument\" -a \"(env status 2>/dev/null | string match -r '\\*?\\s+\\w+' | string split ' ' | string trim | tail -n +2)\" -d 'Environment'")?;
        writeln!(script)?;

        // Scan command options
        writeln!(script, "# scan command options")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from scan; and not __fish_seen_argument\" -a \"(__fish_complete_directories)\" -d 'Directory to scan'")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from scan\" -l format -d 'Output format' -xa 'text json yaml'")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from scan\" -l hidden -d 'Include hidden files and directories'")?;
        writeln!(script)?;

        // Validate command options
        writeln!(script, "# validate command options")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from validate\" -l env -d 'Environment to validate' -xa 'current (env status 2>/dev/null | string match -r '\\*?\\s+\\w+' | string split ' ' | string trim | tail -n +2)'")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from validate\" -l check-unused -d 'Check for unused environment variables'")?;
        writeln!(script)?;

        // Sync command options
        writeln!(script, "# sync command options")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from sync; and not __fish_seen_argument -a 1\" -a \"(env status 2>/dev/null | string match -r '\\*?\\s+\\w+' | string split ' ' | string trim | tail -n +2)\" -d 'Source environment'")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from sync; and not __fish_seen_argument -a 2\" -a \"(env status 2>/dev/null | string match -r '\\*?\\s+\\w+' | string split ' ' | string trim | tail -n +2)\" -d 'Target environment'")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from sync\" -l yes -d 'Skip confirmation before syncing'")?;
        writeln!(script)?;

        // Generate command options
        writeln!(script, "# generate command options")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from generate\" -l output -d 'Output file path' -r")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from generate\" -l comments -d 'Include comments describing each variable'")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from generate\" -l docs -d 'Generate comprehensive documentation'")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from generate\" -l scan-dir -d 'Directory to scan for environment variables' -a \"(__fish_complete_directories)\"")?;
        writeln!(script)?;

        // Status command options
        writeln!(script, "# status command options")?;
        writeln!(script, "complete -c env -n \"__fish_seen_subcommand_from status\" -l verbose -d 'Show detailed information'")?;
        writeln!(script)?;

        // Help option for all commands
        writeln!(script, "# Help option")?;
        writeln!(script, "complete -c env -l help -d 'Show help message'")?;

        Ok(script)
    }

    /// Generate PowerShell completion script.
    fn generate_powershell(&self) -> Result<String> {
        let mut script = String::new();

        // Header
        writeln!(script, "# PowerShell completion for env-cli")?;
        writeln!(script, "# Generated by env-cli completion generation")?;
        writeln!(script)?;

        // Script to register completion
        writeln!(
            script,
            "Register-ArgumentCompleter -Native -CommandName env -ScriptBlock {{"
        )?;
        writeln!(
            script,
            "    param($wordToComplete, $commandAst, $cursorPosition)"
        )?;
        writeln!(script)?;

        writeln!(script, "    # Get current command")?;
        writeln!(
            script,
            "    $command = $commandAst.CommandElements[0].Extent.Text"
        )?;
        writeln!(script)?;

        writeln!(script, "    # Get subcommand if exists")?;
        writeln!(
            script,
            "    $subcommand = if ($commandAst.CommandElements.Count -gt 1) {{"
        )?;
        writeln!(script, "        $commandAst.CommandElements[1].Extent.Text")?;
        writeln!(script, "    }} else {{")?;
        writeln!(script, "        ''")?;
        writeln!(script, "    }}")?;
        writeln!(script)?;

        writeln!(script, "    # Get available environments")?;
        writeln!(script, "    $envs = try {{")?;
        writeln!(script, "        & env status 2>$null | Select-String '^\\*?\\s+\\w+' | ForEach-Object {{ $_.ToString().Split(' ')[1] }} | Where-Object {{ $_ -ne '' }}")?;
        writeln!(script, "    }} catch {{")?;
        writeln!(script, "        @()")?;
        writeln!(script, "    }}")?;
        writeln!(script)?;

        writeln!(script, "    # Completion logic")?;
        writeln!(script, "    $completions = switch -Regex ($subcommand) {{")?;
        writeln!(script)?;

        writeln!(script, "        '^$' {{")?;
        writeln!(script, "            # Main commands")?;
        writeln!(script, "            @('init', 'switch', 'scan', 'validate', 'sync', 'generate', 'status') | ForEach-Object {{")?;
        writeln!(script, "                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "            }}")?;
        writeln!(script, "        }}")?;
        writeln!(script)?;

        writeln!(script, "        '^switch$' {{")?;
        writeln!(script, "            # Environment names for switch")?;
        writeln!(script, "            $envs | ForEach-Object {{")?;
        writeln!(script, "                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', 'Environment name')")?;
        writeln!(script, "            }}")?;
        writeln!(script, "        }}")?;
        writeln!(script)?;

        writeln!(script, "        '^validate$' {{")?;
        writeln!(
            script,
            "            if ($wordToComplete -match '--env=') {{"
        )?;
        writeln!(script, "                # Environment names for validate")?;
        writeln!(script, "                $envs | ForEach-Object {{")?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new(\"--env=$_\", \"--env=$_\", 'ParameterValue', 'Environment name')")?;
        writeln!(script, "                }}")?;
        writeln!(
            script,
            "            }} elseif ($wordToComplete -match '^--') {{"
        )?;
        writeln!(script, "                # Options")?;
        writeln!(script, "                @('--env', '--check-unused', '--help') | Where-Object {{ $_ -like \"$wordToComplete*\" }} | ForEach-Object {{")?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script, "            }} else {{")?;
        writeln!(
            script,
            "                @('--env', '--check-unused', '--help') | ForEach-Object {{"
        )?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script, "            }}")?;
        writeln!(script, "        }}")?;
        writeln!(script)?;

        writeln!(script, "        '^sync$' {{")?;
        writeln!(script, "            # Environment names for sync")?;
        writeln!(script, "            $envs | ForEach-Object {{")?;
        writeln!(script, "                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', 'Environment name')")?;
        writeln!(script, "            }}")?;
        writeln!(script)?;

        writeln!(script, "            if ($wordToComplete -match '^--') {{")?;
        writeln!(script, "                # Options")?;
        writeln!(script, "                @('--yes', '--help') | Where-Object {{ $_ -like \"$wordToComplete*\" }} | ForEach-Object {{")?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script, "            }} else {{")?;
        writeln!(
            script,
            "                @('--yes', '--help') | ForEach-Object {{"
        )?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script, "            }}")?;
        writeln!(script, "        }}")?;
        writeln!(script)?;

        writeln!(script, "        '^scan$' {{")?;
        writeln!(script, "            if ($wordToComplete -match '^--') {{")?;
        writeln!(script, "                # Options")?;
        writeln!(script, "                @('--format', '--hidden', '--help') | Where-Object {{ $_ -like \"$wordToComplete*\" }} | ForEach-Object {{")?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script, "            }} else {{")?;
        writeln!(
            script,
            "                @('--format', '--hidden', '--help') | ForEach-Object {{"
        )?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script, "            }}")?;
        writeln!(script, "        }}")?;
        writeln!(script)?;

        writeln!(script, "        '^generate$' {{")?;
        writeln!(script, "            if ($wordToComplete -match '^--') {{")?;
        writeln!(script, "                # Options")?;
        writeln!(script, "                @('--output', '--comments', '--docs', '--scan-dir', '--help') | Where-Object {{ $_ -like \"$wordToComplete*\" }} | ForEach-Object {{")?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script, "            }} else {{")?;
        writeln!(script, "                @('--output', '--comments', '--docs', '--scan-dir', '--help') | ForEach-Object {{")?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script, "            }}")?;
        writeln!(script, "        }}")?;
        writeln!(script)?;

        writeln!(script, "        '^status$' {{")?;
        writeln!(script, "            if ($wordToComplete -match '^--') {{")?;
        writeln!(script, "                # Options")?;
        writeln!(script, "                @('--verbose', '--help') | Where-Object {{ $_ -like \"$wordToComplete*\" }} | ForEach-Object {{")?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script, "            }} else {{")?;
        writeln!(
            script,
            "                @('--verbose', '--help') | ForEach-Object {{"
        )?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script, "            }}")?;
        writeln!(script, "        }}")?;
        writeln!(script)?;

        writeln!(script, "        '^init$' {{")?;
        writeln!(script, "            if ($wordToComplete -match '^--') {{")?;
        writeln!(script, "                # Options")?;
        writeln!(script, "                @('--force', '--help') | Where-Object {{ $_ -like \"$wordToComplete*\" }} | ForEach-Object {{")?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script)?;

        writeln!(script, "            }} else {{")?;
        writeln!(
            script,
            "                @('--force', '--help') | ForEach-Object {{"
        )?;
        writeln!(script, "                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)")?;
        writeln!(script, "                }}")?;
        writeln!(script, "            }}")?;
        writeln!(script, "        }}")?;
        writeln!(script)?;

        writeln!(script, "        default {{")?;
        writeln!(script, "            # Default: show help")?;
        writeln!(script, "            [System.Management.Automation.CompletionResult]::new('--help', '--help', 'ParameterValue', 'Show help message')")?;
        writeln!(script, "        }}")?;
        writeln!(script)?;

        writeln!(script, "    }}")?;
        writeln!(script)?;

        writeln!(script, "    return $completions")?;
        writeln!(script, "}}")?;

        Ok(script)
    }
}

/// Supported shell types.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Shell {
    Bash,
    Zsh,
    Fish,
    PowerShell,
}

impl std::fmt::Display for Shell {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Shell::Bash => write!(f, "bash"),
            Shell::Zsh => write!(f, "zsh"),
            Shell::Fish => write!(f, "fish"),
            Shell::PowerShell => write!(f, "powershell"),
        }
    }
}

impl std::str::FromStr for Shell {
    type Err = crate::error::EnvCliError;

    fn from_str(s: &str) -> Result<Self> {
        match s.to_lowercase().as_str() {
            "bash" => Ok(Shell::Bash),
            "zsh" => Ok(Shell::Zsh),
            "fish" => Ok(Shell::Fish),
            "powershell" | "pwsh" => Ok(Shell::PowerShell),
            _ => Err(crate::error::EnvCliError::InvalidArgument(format!(
                "Unsupported shell: {}. Supported shells: bash, zsh, fish, powershell",
                s
            ))),
        }
    }
}

/// Install shell completion for the current user.
pub fn install_completion(shell: Shell) -> Result<()> {
    let completion_dir = get_completion_dir(shell)?;
    let completion_file = completion_dir.join(format!("env.{}", shell));

    // Generate completion script
    let generator = CompletionGenerator::new();
    let script = generator.generate(shell)?;

    // Create directory if it doesn't exist
    std::fs::create_dir_all(&completion_dir)?;

    // Write completion script
    std::fs::write(&completion_file, script)?;

    println!(
        "‚úÖ Completion installed for {} at: {}",
        shell,
        completion_file.display()
    );

    // Show installation instructions
    show_completion_instructions(shell, &completion_file)?;

    Ok(())
}

/// Uninstall shell completion.
pub fn uninstall_completion(shell: Shell) -> Result<()> {
    let completion_dir = get_completion_dir(shell)?;
    let completion_file = completion_dir.join(format!("env.{}", shell));

    if completion_file.exists() {
        std::fs::remove_file(&completion_file)?;
        println!(
            "‚úÖ Completion uninstalled for {} from: {}",
            shell,
            completion_file.display()
        );

        // Show uninstallation instructions
        show_uninstallation_instructions(shell)?;
    } else {
        println!(
            "‚ÑπÔ∏è  No completion found for {} at: {}",
            shell,
            completion_file.display()
        );
    }

    Ok(())
}

/// Get the completion directory for the specified shell.
fn get_completion_dir(shell: Shell) -> Result<std::path::PathBuf> {
    let home_dir = dirs::home_dir().ok_or_else(|| {
        crate::error::EnvCliError::Config("Could not find home directory".to_string())
    })?;

    let completion_dir = match shell {
        Shell::Bash => {
            // Check for different completion directory locations
            let dirs = [
                home_dir.join(".local/share/bash-completion/completions"),
                home_dir.join(".bash_completion.d"),
                std::path::PathBuf::from("/etc/bash_completion.d"),
            ];

            dirs.iter()
                .find(|dir| dir.exists() || dir.parent().map_or(false, |p| p.exists()))
                .cloned()
                .unwrap_or_else(|| home_dir.join(".local/share/bash-completion/completions"))
        }
        Shell::Zsh => {
            let zsh_dirs = [
                home_dir.join(".zsh/completions"),
                home_dir.join(".zsh/functions"),
                home_dir.join(".local/share/zsh/site-functions"),
            ];

            zsh_dirs
                .iter()
                .find(|dir| dir.exists() || dir.parent().map_or(false, |p| p.exists()))
                .cloned()
                .unwrap_or_else(|| home_dir.join(".zsh/completions"))
        }
        Shell::Fish => home_dir.join(".config/fish/completions"),
        Shell::PowerShell => {
            let powershell_dirs = [
                home_dir.join(".local/share/powershell/Modules"),
                std::path::PathBuf::from("/usr/local/share/powershell/Modules"),
            ];

            powershell_dirs
                .iter()
                .find(|dir| dir.exists())
                .cloned()
                .unwrap_or_else(|| home_dir.join(".local/share/powershell/Modules"))
        }
    };

    Ok(completion_dir)
}

/// Show installation instructions for the specified shell.
fn show_completion_instructions(shell: Shell, _completion_file: &std::path::Path) -> Result<()> {
    match shell {
        Shell::Bash => {
            println!("üìù To enable bash completion, add the following to your ~/.bashrc or ~/.bash_profile:");
            println!("   source ~/.local/share/bash-completion/completions/env");
            println!("   Or restart your shell to load the completion automatically.");
        }
        Shell::Zsh => {
            println!("üìù To enable zsh completion, add the following to your ~/.zshrc:");
            println!("   fpath=(~/.zsh/completions $fpath)");
            println!("   autoload -U compinit");
            println!("   compinit");
            println!("   Or restart your shell to load the completion automatically.");
        }
        Shell::Fish => {
            println!("üìù Fish completion should work automatically after restarting your shell.");
        }
        Shell::PowerShell => {
            println!("üìù PowerShell completion should work automatically. Restart your PowerShell session if needed.");
        }
    }

    Ok(())
}

/// Show uninstallation instructions.
fn show_uninstallation_instructions(shell: Shell) -> Result<()> {
    match shell {
        Shell::Bash => {
            println!("üìù Remove the 'source ~/.local/share/bash-completion/completions/env' line from your ~/.bashrc or ~/.bash_profile.");
        }
        Shell::Zsh => {
            println!("üìù Remove the completion directory from fpath in your ~/.zshrc if you added it manually.");
        }
        Shell::Fish => {
            println!("üìù No additional cleanup required for fish completion.");
        }
        Shell::PowerShell => {
            println!("üìù No additional cleanup required for PowerShell completion.");
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_shell_from_str() {
        assert_eq!("bash".parse::<Shell>().unwrap(), Shell::Bash);
        assert_eq!("zsh".parse::<Shell>().unwrap(), Shell::Zsh);
        assert_eq!("fish".parse::<Shell>().unwrap(), Shell::Fish);
        assert_eq!("powershell".parse::<Shell>().unwrap(), Shell::PowerShell);
        assert_eq!("pwsh".parse::<Shell>().unwrap(), Shell::PowerShell);
        assert!("unknown".parse::<Shell>().is_err());
    }

    #[test]
    fn test_shell_display() {
        assert_eq!(Shell::Bash.to_string(), "bash");
        assert_eq!(Shell::Zsh.to_string(), "zsh");
        assert_eq!(Shell::Fish.to_string(), "fish");
        assert_eq!(Shell::PowerShell.to_string(), "powershell");
    }

    #[test]
    fn test_completion_generation() {
        let generator = CompletionGenerator::new();

        // Test that all shells can generate completion scripts
        for shell in [Shell::Bash, Shell::Zsh, Shell::Fish, Shell::PowerShell] {
            let result = generator.generate(shell);
            assert!(
                result.is_ok(),
                "Failed to generate completion for {:?}",
                shell
            );

            let script = result.unwrap();
            assert!(
                !script.is_empty(),
                "Completion script is empty for {:?}",
                shell
            );
        }
    }
}
