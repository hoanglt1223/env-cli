//! Initialize command implementation.

use crate::config::{default_config_path, Config, Environment};
use crate::error::{EnvCliError, Result};
use std::path::PathBuf;

/// Initialize a new env-cli project structure.
pub async fn execute(force: bool) -> Result<()> {
    println!("Initializing project environment structure...");

    // Check if already initialized
    let env_dir = PathBuf::from(".env");
    let config_path = default_config_path();

    if env_dir.exists() && !force {
        return Err(EnvCliError::AlreadyInitialized(
            "Project already has .env directory. Use --force to reinitialize.".to_string(),
        ));
    }

    // Create directory structure
    create_directory_structure(&env_dir)?;

    // Create default configuration
    create_default_config(&config_path)?;

    // Create environment templates
    create_environment_templates(&env_dir)?;

    // Set up current environment symlink
    setup_current_environment(&env_dir, "development")?;

    println!("✓ Created .env directory structure");
    println!("✓ Created env-cli configuration file");
    println!("✓ Created environment templates");
    println!("✓ Set 'development' as current environment");

    println!("\nProject initialized successfully!");
    println!("Run 'env status' to see the current state.");
    println!("Run 'env switch <environment>' to switch environments.");

    Ok(())
}

/// Create the directory structure for env-cli.
fn create_directory_structure(env_dir: &PathBuf) -> Result<()> {
    // Main .env directory
    std::fs::create_dir_all(env_dir)?;

    // Environments directory
    std::fs::create_dir_all(env_dir.join("environments"))?;

    // Backups directory
    std::fs::create_dir_all(env_dir.join("backups"))?;

    Ok(())
}

/// Create default configuration file.
fn create_default_config(config_path: &PathBuf) -> Result<()> {
    let project_name = get_project_name()?;

    let config = Config {
        project: project_name,
        default_environment: "development".to_string(),
        environments: vec![
            Environment {
                name: "development".to_string(),
                description: Some("Development environment".to_string()),
                file: Some(PathBuf::from(".env/environments/development.env")),
                variables: std::collections::HashMap::new(),
            },
            Environment {
                name: "staging".to_string(),
                description: Some("Staging environment".to_string()),
                file: Some(PathBuf::from(".env/environments/staging.env")),
                variables: std::collections::HashMap::new(),
            },
            Environment {
                name: "production".to_string(),
                description: Some("Production environment".to_string()),
                file: Some(PathBuf::from(".env/environments/production.env")),
                variables: std::collections::HashMap::new(),
            },
        ],
        scan: Default::default(),
        validation: Default::default(),
    };

    crate::config::save_config(&config, config_path)?;
    Ok(())
}

/// Create environment template files.
fn create_environment_templates(env_dir: &PathBuf) -> Result<()> {
    let environments_dir = env_dir.join("environments");

    // Development environment template
    let dev_env = r#"# Development Environment Configuration
# Generated by env-cli

# Database
DATABASE_URL=postgresql://localhost:5432/myapp_dev
DATABASE_POOL_SIZE=10

# API Configuration
API_KEY=dev-api-key
API_BASE_URL=http://localhost:3000/api
DEBUG_MODE=true

# Feature Flags
FEATURE_NEW_UI=false
FEATURE_ANALYTICS=false
"#;
    std::fs::write(environments_dir.join("development.env"), dev_env)?;

    // Staging environment template
    let staging_env = r#"# Staging Environment Configuration
# Generated by env-cli

# Database
DATABASE_URL=postgresql://staging-db:5432/myapp_staging
DATABASE_POOL_SIZE=20

# API Configuration
API_KEY=staging-api-key
API_BASE_URL=https://staging-api.example.com
DEBUG_MODE=false

# Feature Flags
FEATURE_NEW_UI=true
FEATURE_ANALYTICS=true
"#;
    std::fs::write(environments_dir.join("staging.env"), staging_env)?;

    // Production environment template
    let prod_env = r#"# Production Environment Configuration
# Generated by env-cli
# IMPORTANT: Replace placeholder values with actual production secrets

# Database
DATABASE_URL=postgresql://prod-db:5432/myapp_production
DATABASE_POOL_SIZE=50

# API Configuration
API_KEY=CHANGE_ME_PRODUCTION_API_KEY
API_BASE_URL=https://api.example.com
DEBUG_MODE=false

# Feature Flags
FEATURE_NEW_UI=true
FEATURE_ANALYTICS=true

# Security (configure as needed)
JWT_SECRET=CHANGE_ME_JWT_SECRET
ENCRYPTION_KEY=CHANGE_ME_ENCRYPTION_KEY
"#;
    std::fs::write(environments_dir.join("production.env"), prod_env)?;

    // Environment template file
    let template = r#"# Environment Template
# Use this as a starting point for new environments

# Database Configuration
DATABASE_URL=
DATABASE_POOL_SIZE=10

# API Configuration
API_KEY=
API_BASE_URL=

# Feature Flags
FEATURE_NEW_UI=false
DEBUG_MODE=true

# Add your custom environment variables here
# VARIABLE_NAME=variable_value
"#;
    std::fs::write(environments_dir.join(".template"), template)?;

    Ok(())
}

/// Set up current environment symlink.
fn setup_current_environment(env_dir: &PathBuf, env_name: &str) -> Result<()> {
    let current_path = env_dir.join(".current");
    let target_path = PathBuf::from("environments").join(format!("{}.env", env_name));

    // Remove existing .current if it exists
    if current_path.exists() {
        std::fs::remove_file(&current_path)?;
    }

    // Create symlink
    #[cfg(unix)]
    {
        std::os::unix::fs::symlink(&target_path, &current_path)?;
    }

    #[cfg(windows)]
    {
        std::os::windows::fs::symlink_file(&target_path, &current_path)?;
    }

    Ok(())
}

/// Get project name from Cargo.toml or current directory.
fn get_project_name() -> Result<String> {
    // Try to read from Cargo.toml
    if let Ok(cargo_toml) = std::fs::read_to_string("Cargo.toml") {
        for line in cargo_toml.lines() {
            if line.trim().starts_with("name = ") {
                // Extract name from: name = "project-name"
                if let Some(start) = line.find('"') {
                    if let Some(end) = line.rfind('"') {
                        if start < end {
                            return Ok(line[start + 1..end].to_string());
                        }
                    }
                }
            }
        }
    }

    // Fallback to directory name
    match std::env::current_dir() {
        Ok(path) => {
            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                Ok(name.to_string())
            } else {
                Ok("env-cli-project".to_string())
            }
        }
        Err(_) => Ok("env-cli-project".to_string()),
    }
}
